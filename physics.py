"""
Note: we use matrix indexing, so row indexing is the first or x dimension and column indexing
is the second or y dimension. 
"""

from functools import partial

import numpy as np

import jax
import jax.numpy as jnp

from utils import bfs


def violates_strong_pauli_exclusion(R):
	"""Checks for three particles at the same point."""
	_, counts = jnp.unique(R, axis=0, return_counts=True)
	return jnp.any(counts >= 3)


def violates_pauli_exclusion(q_point, q):
	"""Checks if placing a test particle at 'r' would place three particles at the same point."""
	too_many_particles = jnp.count_nonzero(q_point) >= 2
	like_charges = jnp.any(q_point == q)
	return too_many_particles | like_charges


def normalize(A):
	"""Normalize an array of vectors."""
	return A / jnp.linalg.vector_norm(A, axis=-1, keepdims=True)


@jax.jit
def lattice_distance(r, s):
	"""Compute lattice distance between points r and s."""
	return jnp.linalg.norm(r - s, ord=1, axis=-1)


@jax.jit
def lattice_distances(r, S):
	"""
	Compute lattice distance between point r and every point in the array S.
	The last dimension of S should have the same size as r. 
	"""
	return jnp.linalg.norm(r - S, axis=-1)


def canonical_shortest_path(r_start, r_end, n):
	"""
	Returns a canonical shortest path between r_start and r_end, where we take 
	a staircase path until we reach a straight line to r_end. 
	"""
	r_diff = r_end - r_start
	r_diff_sign = jnp.sign(r_diff)
	r_diff_abs = jnp.abs(r_diff)
	length = jnp.sum(r_diff_abs)
	i_square_half = jnp.abs(jnp.min(r_diff))
	i_square *= 2
	element_square = r_start + (r_diff_sign * jnp.array((i_square_half, i_square_half)))
	step_outside_square = jnp.where(
		r_diff_abs[0] >= r_diff_abs[1], jnp.array([1, 0]), jnp.array([0, 1]))
	padding = jnp.array((-1, -1), dtype=int)

	def path_creator(i, j):
		half, parity = i // 2, i % 2
		i_diff = i - i_square
		element_within_square = r_start + (r_diff_sign * jnp.array((half + parity, half)))
		element_outside_square = element_square + (i_diff * step_outside_square)
		element_on_path = jax.lax.select_n(
			i <= i_square, element_outside_square, element_within_square)
		element = jax.lax.select_n(i > length, element_on_path, padding)
		return element

	path = jnp.fromfunction(path_creator, (n, 2), dtype=int)
	return path


def shift_path(path, r): 
	return path + r - path[0]


def append_on_path(path, r):
	insert_id = jnp.argmin(path, axis=0)[0]
	return jnp.insert(path, insert_id, r, axis=0)


def lattice_positions(n):
	return jnp.stack(jnp.indices((n, n)), axis=-1)


def boundaries(r, delta):
	#### THIS IS WRONG, NOT PERIODIC
	x, y = r
	min_x = jnp.clip(x - delta, min=0)
	min_y = jnp.clip(y - delta, min=0)
	max_x, max_y = x + delta, y + delta
	return min_x, max_x, min_y, max_y


def centered_square(L, r, delta):
	"""
	Generate the subset of the lattice 'L' consisting of a square of radius 'delta' centered at 'r',
	along with the positions in that subset.  
	"""
	min_x, max_x, min_y, max_y = boundaries(r, delta)
	square = L[min_x: max_x+1, min_y: max_y+1]
	x_positions = jnp.arange(min_x, max_x+1)
	y_positions = jnp.arange(min_y, max_y+1)
	positions = jnp.stack(jnp.meshgrid(x_indices, y_indices, indexing="ij"), axis=-1)
	return square, positions


@partial(jax.jit, static_argnums=[3])
def generate_lattice(R, n, pad_value, sites=3):
	"""
	Generate the occupation lattice corresponding to R. The lattice is nxnxsites, 
	with 'sites' slots per position of the lattice, to accomodate test positions; 
	occupation is indicated by a particle index in one of the slots. 
	"""
	k = R.shape[0]
	L = jnp.full((n, n, sites), pad_value, dtype=int)
	counts = jnp.zeros((n, n), dtype=int)

	def particle_fn(L, counts, i, x, y):
		idx = counts[x, y]
		L = L.at[x, y, idx].set(i)
		counts = counts.at[x, y].add(1)
		return (L, counts)

	def padding_fn(L, counts, *args):
		return L, counts

	def map_point(i, args):
		L, counts = args
		x, y = R[i, 0], R[i, 1]
		return jax.lax.cond(x == pad_value, padding_fn, particle_fn, L, counts, i, x, y)

	L, _ = jax.lax.fori_loop(0, k, map_point, (L, counts))
	return L


def unlabel_lattice(L, pad_value):
	return jnp.sum(L != pad_value, axis=-1)


def generate_unlabeled_lattice(R, n):
	"""
	Generate the unlabeled occupation lattice corresponding to R. The lattice is an nxn Array; 
	occupation is indicated by 0, 1, or 2, indicating the number of particles in the site. 
	"""
	L = jnp.zeros((n, n), dtype=int)
	L = L.at[R[:, 0], R[:, 1]].add(1)
	return L


def generate_property_lattice(L, C, pad_value):
	"""Gather property values from a 1D Array C using indices in an Array L while ignoring padding."""
	return jnp.where(L != pad_value, C[L], pad_value)


def potential_everywhere(R, Q, positions, point_func):
	"""
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.
	positions
		Array of all positions in the space. 3D, nxnx2. 
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	"""
	differences = jnp.expand_dims(positions, axis=-2) - R
	distances = jnp.linalg.norm(differences, ord=1, axis=-1)
	V_expanded = Q * point_func(distances)
	V = jnp.sum(V_expanded, axis=-1)
	return V


def potential_energy_all(R, Q, V):
	"""
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.
	V
		Array of potentials at all positions in space. 2D, nxn.
	"""
	U = Q * V[R[:, 0], R[:, 1]]
	return U


def test_potential_factors(r, L, LQ, rho, point_func):
	"""
	Computes the individual contribution to the potential at 'r' produced by each particle. 
	Returns a square lattice of source potential values around 'r' of radius 'rho'.

	r
		Position we are computing the potential at. 1D, 2. 
	L
		Array of lattice points, with three sites per point filled with either a particle index
		or pad_value. 3D, nxnx3, pad_value-padded.
	LQ
		Array of lattice points, with three sites per point filled with either a particle charge
		or 0. 3D, nxnx3, 0-padded.
	rho
		Integer giving the range of the potential.
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	"""
	Lr_square, Lr_square_positions = centered_square(L, r, rho)
	Qr_square, _ = centered_square(LQ, r, rho)
	distances = lattice_distances(r, Lr_square_positions)
	V_expanded = Qr_square * point_func(distances)
	return V_expanded, Lr_square


@partial(jax.jit, static_argnums=[3, 4, 5, 6])
def test_potential(r, L, LQ, rho, point_func, pad_value, pauli_exclusion=False):
	"""
	The potential at 'r' generated by particles in the occupation lattices L and LQ, 
	with the shape of the potential generated by a point source determined by point_func. 
	When determining the potential energy of a particle i using this function the particle 
	itself should not be included in these lattices, only (at minimum) all other particles 
	that can interact via the potential with i. As such it cannot properly and fully factor in
	Pauli exclusion; for efficiency we set the option off by default, assuming that 
	Pauli exclusion is obeyed everywhere. 

	r
		Position we are computing the potential at. 1D, 2. 
	L
		Array of lattice points, with three sites per point filled with either a particle index
		or pad_value. 3D, nxnx3, pad_value-padded.
	LQ
		Array of lattice points, with three sites per point filled with either a particle charge
		or 0. 3D, nxnx3, 0-padded.
	rho
		Integer giving the range of the potential.
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	pad_value
		Scalar.
	pauli_exclusion
		Boolean indicating whether to apply Pauli exclusion based on charge polarity or not.
	"""
	def compute():
		V_expanded, _ = test_potential_factors(r, L, LQ, rho, point_func)
		V = jnp.sum(V_expanded)
		return V

	if pauli_exclusion:
		r_sites, r_qsites = L[r], LQ[r]
		three_particles = jnp.all(r_sites != pad_value)
		one_particle = jnp.all(r_sites[1:] == pad_value)
		pauli_valid = jnp.all(jnp.unique_counts(r_qsites).counts == 1)
		finite = ~(three_particles) & (one_particle | pauli_valid)
		V = jax.lax.cond(finite, compute, lambda: jnp.inf)
	else:
		V = compute()

	return V


def potential_for(V_test, q_point, q):
	"""
	Calculates the potential of a test particle from the test potential, 
	incoporating Pauli exclusion of like charges.
	"""
	violates_pe = violates_pauli_exclusion(q_point, q)
	return jnp.where(violates_pe, jnp.inf, V_test)


def potential_energy(V, q):
	return jnp.where(V == jnp.inf, jnp.inf, q * V)


def make_potential_energy_func(L, LQ, rho, point_func, pad_value):
	
	def func(r, q):
		V_test = test_potential(r, L, LQ, rho, point_func, pad_value)
		V = potential_for(V_test, LQ[r], q)
		U = potential_energy(V, q)
		return U

	return func


@partial(jax.jit, static_argnums=[4, 5, 6, 7])
def potential_energy_factors(r, q, L, LQ, rho, point_func, factor_limit, pad_value=-1):
	"""
	Computes the individual contribution to the potential energy of a particle at 'r'
	of charge 'q' produced by each other particle. Assumes all potential factors are finite; 
	i.e. Pauli exclusion is never violated in 'L'. 

	r
		Position we are computing the potential at. 1D, 2. 
	q
		Scalar, charge of the particle. 
	L
		Array of lattice points, with three sites per point filled with either a particle index
		or pad_value. 3D, nxnx3, pad_value-padded.
	LQ
		Array of lattice points, with three sites per point filled with either a particle charge
		or 0. 3D, nxnx3, 0-padded.
	rho
		Integer giving the range of the potential.
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	factor_limit
		Integer scalar giving the maximum number of particles within potential range of i. 
	pad_value
		Integer scalar used for padding to remove most zero energy factors. Defaults to -1. 
	"""
	potential_factors, Lr_square = test_potential_factors(r, L, LQ, rho, point_func)
	energy_factors = potential_energy(potential_factors, q)
	nonzero_lattice_indices = jnp.nonzero(energy_factors, size=factor_limit, fill_value=pad_value)
	indices = Lr_square[nonzero_lattice_indices]
	energy_factors = energy_factors[nonzero_lattice_indices]
	return energy_factors, indices


def potential_energy_factors_bulk(j, prev_bound_states, curr_bound_states, 
								  all_energy_factors, all_factor_indices, pad_value=-1):
	"""Assumes prev_bound_states is a refinement of curr_bound_states."""
	k = curr_bound_states.shape[0]
	new_particles_mask = jnp.logical_xor(curr_bound_states == j, prev_bound_states == j)
	filtered_energies = jnp.where(new_particles_mask, all_energy_factors, 0)
	filtered_indices = jnp.where(new_particles_mask, all_factor_indices, pad_value)
	energy_factors = jnp.zeros(k)
	energy_factors = energy_factors.at[filtered_indices].add(filtered_energies)
	return energy_factors


def bonded(U, max_energy):
	return U <= max_energy


def compute_bonds(i, energy_factors, factor_indices, max_energy, pad_value):
	"""
	Calculates the bonds of particle i, with bonds defined by a maximum energy of i due to the bond.
	Assumes that particle i is bonded and max_energy < 0. Returns a padded 1D Array 
	containing the indices of particles bonded to i, sorted by increasing bond energy.  

	energy_factors:
		Array containing portions of the potential energy of particle i 
		generated by the interaction of other particles. 1D. 
	"""
	sorted_indices = jnp.argsort(energy_factors)
	energy_factors = energy_factors[sorted_indices]
	factor_indices = factor_indices[sorted_indices]

	def find_bond(args):
		remaining_energies = args[1]
		energy_sums = jnp.cumsum(remaining_energies)
		index = jnp.searchsorted(energy_sums, max_energy, method="scan")	# change method for GPU
		remaining_energies = remaining_energies.at[:index+1].set(0)
		return index, remaining_energies

	def end_fn(args):
		index, remaining_energies = args
		return index == 0 and remaining_energies[0] == 0

	index, _ = jax.lax.while_loop(end_fn, find_bond, (0, energy_factors))
	factor_indices = factor_indices.at[index+1:].set(pad_value)
	return factor_indices


def compute_bound_state(i, all_bonds, pad_value):
	"""
	i
		Index of the particle whose bound state we are computing. 
	all_bonds
		Array of indices, pad_value-padded, which indicates the particles bonded 
		to each particle of the system. 2D, kxm.
 	"""
	state = bfs(all_bonds, i, pad_value)
	return state


def compute_bound_states(all_bonds, pad_value):
	"""
	Calculates all of the bound states, or "molecules", specified by the array all_bounds. 
	Returns a 1D Array of size k giving the label integer of the bound state associated to each particle. 
	"""
	k = all_bonds.shape[0]
	curr_particle = jnp.int32(0)
	visited = jnp.zeros(k, dtype=bool)
	bound_states = jnp.zeros(k, dtype=int)
	bound_state_count = jnp.int32(-1)

	def cond_fn(args):
		visited = args[1]
		return jnp.all(visited)

	def get_molecule(curr_particle, visited, bound_states):
		bound_state_count += 1
		molecule = compute_bound_state(curr_particle, all_bonds, pad_value)
		bound_states = bound_states.at[molecule].set(bound_state_count)
		visited = visited.at[molecule].set(True)
		curr_particle += 1
		return curr_particle, visited, bound_states

	def body_fn(args):
		curr_particle, visited, bound_states = args
		seen = visited[curr_particle]
		next_fn = lambda j, *args: (j+1,) + args
		return jax.lax.cond(seen, next_fn, get_molecule, *args)

	bound_states = jax.lax.while_loop(cond_fn, body_fn, (curr_particle, visited, bound_states))[-1]
	return bound_states


def get_particles(I, bound_states, pad_value):
	
	def collection_fn(i):
		molecule_id = bound_states[i]
		return jnp.where(jnp.isin(molecule_id, I), i, pad_value)

	I_particles = jnp.fromfunction(collection_fn, bound_states.shape, dtype=int)
	return I_particles


def bound_state_indices(I, bound_states, pad_value):
	
	def collection_fn(i):
		idx = jnp.argmax(I == i)
		return jnp.where(I[idx] == i, idx, pad_value)

	indices = jax.vmap(collection_fn)(bound_states)
	return indices


def centers_of_mass(R, M, bound_states):
	"""
	Returns the center of mass and mass of each bound state 
	in a 0-padded 'k' length 2D Array and 1D Array, respectively.
	"""
	k = R.shape[0]
	position_sums = jnp.zeros((k, 2), dtype=int)
	mass_sums = jnp.zeros((k,), dtype=int)
	position_sums = position_sums.at[bound_states].add(M*R)
	mass_sums = mass_sums.at[bound_states].add(M)
	# use a mask to handle padding
	centers = jnp.where(mass_sums > 0, position_sums / mass_sums, 0)	
	return centers, mass_sums


def moments_of_inertia(R, M, coms, bound_states):
	"""Returns the moment of inertia of each bound state in a 0-padded 'k' length 1D Array."""
	k = R.shape[0]
	MOIs = jnp.zeros((k,))
	arm_lengths = lattice_distance(R, coms)
	particle_MOIs = M * arm_lengths
	MOIs = MOIs.at[bound_states].add(particle_MOIs)
	return MOIs


def move(R, curr_coms, new_coms):
	"""Move each particle using reference points."""
	return R + new_coms - curr_coms


def standardize_angle(theta):
	"""Standardizes an angle to between 0 and 360 degrees."""
	return theta % 360


def rotate(R, coms, thetas):
	"""
	Rotates each particle about a given center of mass by a multiple 'theta' of 90 degrees,
	upper bounded by 270 degrees. 

	R
		Array of particle positions. 2D, kx2.
	coms
		Array of centers of mass. 2D, kx2.
	thetas
		Array of angles. 1D, k. 
	"""
	# if at all slow could convert to direct array creation
	rotate_matrix90 = jnp.array([[0, -1], [1, 0]])
	rotate_matrix180 = jnp.array([[-1, 0], [0, -1]])
	rotate_matrix270 = jnp.array([[0, 1], [-1, 0]])

	@partial(jax.jit, static_argnums=[1])
	def origin_rotate(r, theta=90):
		if theta == 0:
			r_new = r
		elif theta == 90:
			r_new = rotate_matrix90 @ r 
		elif theta == 180:
			r_new = rotate_matrix180 @ r
		elif theta == 270:
			r_new = rotate_matrix270 @ r
		return r_new

	rotation_branches = tuple(partial(origin_rotate, theta=i) for i in (0, 90, 180, 270))
	
	def rotation_fn(r, com, theta):
		theta_idx = theta // 90
		r_centered = r - com
		r_centered_rotated = jax.lax.switch(theta_idx, rotation_branches, r_centered)
		r_rotated = r_centered_rotated + com
		return r_rotated

	R_rotated = jax.vmap(rotation_fn)(R, coms, thetas)
	return R_rotated


def difference_arrays(V):
	x_diffs = jnp.diff(V, axis=0)
	y_diffs = jnp.diff(V, axis=-1)
	zero_row = jnp.zeros((1, V.shape[-1]))
	zero_col = jnp.zeros((V.shape[0], 1))
	x_delta = jnp.concatenate(zero_row, x_diffs, zero_row, axis=0)
	y_delta = jnp.concatenate(zero_col, y_diffs, zero_col, axis=-1)
	return x_delta, y_delta


def generate_interaction_field(V):
	# multiply by charge to get force
	Vx_delta, Vy_delta = difference_arrays(V)
	x_component = (Vx_delta[1:, :] + Vx_delta[:-1, :]) / 2
	y_component = (Vy_delta[:, 1:] + Vy_delta[:, :-1]) / 2
	return jnp.stack(x_component, y_component)


@jax.jit
def planck_logdensity_fn(F, beta, alpha, delta):
	return jnp.log(alpha) + (jnp.log(F) * 3) - jnp.log(jnp.exp(beta * delta * F) - 1)


@jax.jit
def gamma_logdensity_fn(x, a, theta):
	return jnp.log(x)*(a - 1) - (x / theta)


@partial(jax.jit, static_argnums=[1, 2, 3, 4, 5, 6])
def planck(key, beta, alpha, delta, theta, M, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample_gamma(data):
		key, _ = data
		key, subkey = jax.random.split(key)
		F = jnp.exp(jax.random.loggamma(subkey, 4)) * theta
		return key, F

	@jax.jit
	def sample(key):

		@jax.jit
		def reject_fn(data):
			key, F = data
			key, subkey = jax.random.split(key)
			planck_logdensity = planck_logdensity_fn(F, beta, alpha, delta)
			gamma_logdensity = gamma_logdensity_fn(F, 4, theta)
			accept_ratio = jnp.exp(planck_logdensity - jnp.log(M) - gamma_logdensity)
			u = jax.random.uniform(subkey)
			return u >= accept_ratio

		key, F = sample_gamma((key, 0))
		_, F = jax.lax.while_loop(reject_fn, sample_gamma, (key, F))
		return F

	samples = jax.vmap(sample)(keys)
	return samples


@partial(jax.jit, static_argnums=[1, 2, 3])
def wien_approximation(key, beta, alpha, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample(key):
		return jnp.exp(jax.random.loggamma(key, 4) - jnp.log(alpha) - jnp.log(beta))

	samples = jax.vmap(sample)(keys)
	return samples


def occupation_mask(n, R):
	"""
	Returns a particle occupation indicator array for an nxn space, 
	based on the particle positions contained in R.

	n
		Number of lattice sites in each dimension of the space.
	R
		Array of particle positions. 2D, kx2. 
	"""
	mask = jnp.zeros((n, n), dtype=int).at[R[:, 0], R[:, 1]].set(1)
	return mask


def masked(x, y, occupation_mask):
	"""
	Implements drive masking that treats particles as perfect barriers. 
	Returns 0 if there is a particle in {x} x [0,y), 1 otherwise. 
	"""
	column = occupation_mask[x]
	i = jnp.argmax(column)
	v = jnp.max(column)
	return v == 0 or y <= i


@partial(jax.jit, static_argnums=[0, 3])
def generate_drive_field(n, R, top_field, mask_func):
	occupied = occupation_mask(n, R)
	field = jnp.broadcast_to(top_field, (n, n))
	mask_func = lambda x, y: mask_func(x, y, occupied)
	particle_mask = jnp.fromfunction(masked, (n, n), dtype=int)
	return jnp.stack((jnp.zeros((n, n)), particle_mask * field), axis=-1)


@partial(jax.jit, static_argnums=[1, 2, 3])
def brownian_noise(key, beta, gamma, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample(key):
		return jnp.sqrt(2*gamma / beta) * jax.jax.random.normal(key)

	samples = jax.vmap(sample)(keys)
	return samples


def compute_velocity_bound(i, r, interaction_field, brownian_field, external_field, energy_field, 
						   transfer_field, mass, charge, molecule_mass, gamma, time_unit):
	nontransfer_force = ((charge * interaction_field[r]) + (mass * external_field[r]) 
						 + (jnp.sqrt(mass) * brownian_field[r]))
	transfer_force = mass * transfer_field[i]
	nontransfer_velocity = nontransfer_force / (gamma * mass)
	transfer_velocity = transfer_force / (gamma * molecule_mass)
	distance = jnp.linalg.vector_norm(nontransfer_velocity + transfer_velocity) * time_unit
	distance += jnp.sqrt(2 * energy_field[r] / mass) * time_unit
	return distance


def energy_barrier(path, potential_energy_func, max_boundary_energy, coupling_constant, lower_bound):
	"""
	Calculates the energy barrier encountered by a particle moving along a path
	from a potential and coupling constant. 

	path 
		Array of adjacent positions, (-1)-padded. 2D, nx2. Assuming the path is length at most n-1. 
	potential_func
		Function that takes a particle index and a position 
		and returns the potential at that position relative to the particle.
	max_boundary_energy
		Scalar.
	coupling_constant
		Scalar. 
	lower_bound
		Scalar giving a lower bound for the potential energy. 
	"""
	end = jnp.argmin(path, axis=0)[0] - 1

	def step_fn(i, max_energy):
		energy = potential_energy_func(path[i], coupling_constant)
		return jnp.max(jnp.array((energy, max_energy)))

	max_energy = jax.lax.fori_loop(1, end, step_fn, lower_bound)
	max_energy = jnp.max(jnp.array((max_energy, max_boundary_energy)))
	return max_energy - max_boundary_energy


def calculate_work(path, field, coupling_constant):
	"""
	Calculates the work done by a field on a particle moving along a path, 
	with the strength of the interaction determined by the appropriate 
	coupling constant of the particle (e.g. charge or mass). Also calculates
	the total work done by the field on the system, returning both values. 

	path
		Array of pairwise adjacent positions, (-1)-padded. 2D, lx2. 
		Assuming the path is length at most l-1. 
	field
		Array of field values at each position in space. 2D, nxnx2.
	coupling_constant
		Scalar. 
	"""
	steps = jnp.diff(path, axis=0)
	end = jnp.argmin(path, axis=0)[0] - 1

	def add_work_step(i, vals):
		work, total_work = vals
		r = path[i]
		delta = steps[i]
		field_val = field[r]
		work_step = jnp.dot(field_val, delta)
		total_work_step = jnp.linalg.vector_norm(field_val)
		return work + work_step, total_work + total_work_step

	work, total_work = jax.lax.fori_loop(0, end, add_work_step, (0, 0))
	# multiply coupling at the end for efficiency
	return coupling_constant * work, coupling_constant * total_work


def calculate_work_v2(path, field, coupling_constant):
	"""
	Calculates the work done by a field on a particle moving along a path, 
	with the strength of the interaction determined by the appropriate 
	coupling constant of the particle (e.g. charge or mass).

	path
		Array of adjacent positions, (-1)-padded. 2D, nx2. Assuming the path is length at most n-1. 
	field
		Array of field values at each position in space. 2D, nxnx2.
	coupling_constant
		Scalar. 
	"""
	steps = jnp.diff(path, axis=0)
	end = jnp.argmin(path, axis=0)[0] - 1

	def work_step(r, delta):
		return jnp.dot(field[r], delta)

	work_steps = jax.vmap(work_step)(path, steps)
	work_steps[end] = 0		# to remove contribution from last fake delta
	work = jnp.sum(work_steps)

	return coupling_constant * work 	# multiply coupling at the end for efficiency


def calculate_total_work(total_path_work, brownian_field, slow_field, 
						 external_field, mass, r_start, r_end, d):
	diff_norm = jnp.linalg.norm(r_end - r_start)
	excess_force_magnitude = mass * (jnp.linalg.norm(external_field[r_end]) 
							 		 + jnp.linalg.norm(slow_field[r_start]))
	excess_force_magnitude += jnp.sqrt(mass) * jnp.linalg.norm(brownian_field[r_start])
	total_work = total_path_work + (excess_force_magnitude * (d - diff_norm))
	return total_work


def calculate_end_field(brownian_field, slow_field, external_field, 
						energy_field, transfer_field, i, r_start, r_end, gamma):
	extra_field = jnp.sqrt(2 * energy_field[r_start] / mass) * gamma
	return (brownian_field[r_start] + slow_field[r_start] 
			+ external_field[r_end] + extra_field + transfer_field[i])


def calculate_torque(r, r_axis, f_vector):
	position_vec = r - r_axis
	return jnp.cross(position_vec, f_vector)


def cross_1D(y_1D, x_2D):
	y_3D = jnp.concatenate((jnp.array((0, 0)), y_1D))
	x_3D = jnp.concatenate((x_2D, jnp.array((0,))))
	return jnp.cross(y_3D, x_3D)[:1]


def transferred_field(r_source, force_source, r_dest, m_block, I_block, torque):
	angular_component = jnp.cross(torque, r_dest - r_source) / I_block
	linear_component = force_source / m_block
	return linear_component + angular_component


def generate_full_transferred_field(I, net_field, R, bound_states, masses, coms, MOIs, I_all, pad_value):
	"""
	I
		Array of particle indices specifying a subset of the particles. 1D, l, pad_value-padded.
	net_field
		Array giving a field experienced by each particle in its current state. 2D, kx2. 
	R
		Array of particle positions. 2D, kx2. 
	bound_states
		Array giving the bound state index for each particle. 1D, k.
	masses
		Array giving the mass of each bound state, 0-padded. 1D, k.
	coms
		Array giving the center of mass of each bound state, 0-padded. 1D, kx2.
	MOIs 
		Array giving the moment of inertia of each bound state, 0-padded. 1D, k.
	I_all
		Array containing the indices of all particles. 1D, k.
	pad_value
		Scalar.
	"""
	def source_factors(i):
		r, molecule_id = R[i], bound_states[i]
		mass, com, MOI = masses[molecule_id], coms[molecule_id], MOIs[molecule_id]
		field_i = net_field[i]
		weighted_torque_i = mass * calculate_torque(r, com, field_i) / MOI
		torque_field_part = cross_1D(weighted_torque_i, -r)
		return field_i, weighted_torque_i, torque_field_part

	field_parts, weighted_torques, torque_field_parts = jax.vmap(source_factors)(I)
	molecules_I = bound_states[I]

	def collect_by_molecule(i):
		particles_mask = (I != pad_value) & (molecules_I == i)
		field_part = jnp.sum(particles_mask * field_parts, axis=0)
		weighted_torque = jnp.sum(particles_mask * weighted_torques, axis=0)
		torque_field_part = jnp.sum(particles_mask * torque_field_parts, axis=0)
		return field_part, weighted_torque, torque_field_part

	molecule_indices = jnp.arange(masses.shape[0])
	field_parts, weighted_torques, torque_field_parts = jax.vmap(collect_by_molecule)(molecule_indices)

	def calculate_transfer(i):
		r, molecule_id = R[i], bound_states[i]
		field_part = field_parts[molecule_id]
		torque_field_part1 = torque_field_parts[molecule_id]
		weighted_torque = weighted_torque[molecule_id]
		torque_field_part2 = cross_1D(weighted_torque, r)
		return field_part + torque_field_part1 + torque_field_part2

	transfer_field = jax.vmap(calculate_transfer)(I_all)
	return transfer_field


def transfer_mask(excess_works, potential_energies, epilson):
	return excess_works < epsilon * potential_energies


def calculate_boundstate_work(self, i, bound_states, net_field, R, start_com, end_com, end_theta):
	particle_mask = bound_states == i

	# total force
	forces = self.M * particle_mask * net_field
	total_force = jnp.sum(forces, axis=0)

	# translation work
	delta = end_com - start_com
	translate_work = jnp.dot(total_force, delta)

	# total torque
	torques = calculate_torque(R, start_com, forces)
	total_torque = jnp.sum(torques, axis=0)

	# rotation work
	rotate_work = jnp.dot(total_torque, jnp.deg2rad(end_theta))

	work = translate_work + rotate_work
	return work, total_force, total_torque


def calculate_excitations(i, R, L, work, delta):
	"""
	Calculates the energy received by each particle in an energy emission event.
	Uses a simple dispersal method where each particle within 'delta' distance 
	receives an energy amount proportional to its distance from the source particle i. 
	No screening from other particles.

	i
		Index of the particle generating the spontaneous emission. 
	R
		Array of particle positions. 2D, kx2.
	L
		Array of lattice sites, with each element indicating whether the site is empty 
		or filled by 1 or 2 particles. Assumes at most two particles may occupy each site. 
		2D, nxn. 
	work
		Scalar, the amount of work released during the emission. 
	delta
		Range of radiation emission. 

	Returns:
		An Array representing a delta radius square around i with each element 
		giving the amount of energy received at that position. 
	"""
	r = R[i]
	r_square, r_square_positions = centered_square(L, r, delta)
	distances = lattice_distances(r, r_square_positions)

	excited_mask = (distances <= delta) and (distances != 0)	# exclude r itself from excitation
	excited_particle_mask = (r_square != 0) & excited_mask

	inv_distances = 1 / distances
	inv_distances = inv_distances.at[inv_distances == jnp.inf].set(0)
	# factor of 2 to account for two particle sites at each posiiton
	normalizer = 1 / jnp.sum(2 * inv_distances * excited_mask)	

	excitations = normalizer * work * inv_distances * excited_particle_mask
	return excitations, r_square_positions


def excitation_mask(excess_works, potential_energies, epilson):
	return excess_works >= epsilon * potential_energies


def merge_excitations(R, L, excitation_arrays, position_arrays):
	"""
	Returns an energy field, a 3D array of shape nxnx2 giving an 'energy vector' at each lattice site. 
	R 
		Array of particle positions. 2D, kx2. 
	L
		Array of lattice sites, with each element indicating whether the site is empty 
		or filled by 1 or 2 particles. Assumes at most two particles may occupy each site. 
		2D, nxn. 
	excitation_arrays
		Array where each row is a 2D array of energies. 3D, mxdxd.
	position_arrays
		Array where each row is a 3D array giving the positions corresponding to the energies
		in excitation_arrays. 4D, mxdxdx2. 
	"""
	excitation_vectors = normalize(position_arrays - R)
	excitation_arrays = jnp.expand_dims(excitation_arrays, axis=-1) * excitation_vectors
	energy_field = jnp.zeros(L.shape + (2,), dtype=float)
	positions = position_arrays.reshape(-1, 2)
	excitations = excitation_arrays.reshape(-1, 2)
	energy_field = energy_field.at[positions[:, 0], positions[:, 1], :].add(excitations)
	return energy_field


def calculate_excitation_work(r_start, r_end, energy_field):
	"""
	Calculates the absorbed work and total work produced by an energy field on a particle 
	travelling from 'r_start' to 'r_end'. 
	"""
	update_vec = r_end - r_start
	excitation = energy_field[r_start]
	energy = jnp.linalg.vector_norm(excitation)
	excitation_work = jnp.max(jnp.array(jnp.dot(excitation, update_vec), energy))
	total_excitation_work = jnp.linalg.vector_norm(excitation)
	return excitation_work, total_excitation_work