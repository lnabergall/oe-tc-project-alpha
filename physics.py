from functools import partial

import numpy as np

import jax
import jax.numpy as jnp

from utils import bfs


@jax.jit
def lattice_distance(r, s):
	"""Compute lattice distance between points r and s."""
	return jnp.linalg.norm(r - s, ord=1, axis=-1)


@jax.jit
def lattice_distances(r, S):
	"""
	Compute lattice distance between point r and every point in the array S.
	The last dimension of S should have the same size as r. 
	"""
	return jnp.linalg.norm(r - S, axis=-1)


def boundaries(r, delta):
	x, y = r
	min_x = jnp.clip(x - delta, min=0)
	min_y = jnp.clip(y - delta, min=0)
	max_x, max_y = x + delta, y + delta
	return min_x, max_x, min_y, max_y


def centered_square(L, r, delta):
	min_x, max_x, min_y, max_y = boundaries(r, delta)
	square = L[min_x: max_x+1, min_y: max_y+1]
	x_positions = jnp.arange(min_x, max_x)
	y_positions = jnp.arange(min_y, max_y)
	positions = jnp.stack(jnp.meshgrid(x_indices, y_indices)).transpose(1, 2, 0)
	return square, positions


def generate_lattice(R, n, pad_value):
	"""
	Generate the occupation lattice corresponding to R. The lattice is nxnx2, 
	with two slots per position of the lattice; occupation is indicated by a particle index
	in one of the slots. 
	"""
	k = R.shape[0]
	L = jnp.full((n, n, 2), pad_value, dtype=int)
	counts = jnp.zeros((n, n), dtype=int)

	def map_point(i, args):
		L, counts = args
		x, y = R[i, 0], R[i, 1]
		idx = counts[x, y]
		L = L.at[x, y, idx].set(i)
		counts = counts.at[x, y].add(1)
		return (L, counts)

	L, _ = jax.lax.fori_loop(0, k, map_point, (L, counts))
	return L


def potential_everywhere(R, Q, positions, point_func):
	"""
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.
	positions
		Array of all positions in the space. 3D, nxnx2. 
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	"""
	differences = jnp.expand_dims(positions, axis=-2) - R
	distances = jnp.linalg.norm(differences, ord=1, axis=-1)
	V_expanded = Q * point_func(distances)
	V = jnp.sum(V_expanded, axis=-1)
	return V


def potential_energy_everywhere(R, Q, V):
	"""
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.
	V
		Array of potentials at all positions in space. 2D, nxn.
	"""
	U = Q * V[R[:, 0], R[:, 1]]
	return U


@partial(jax.jit, static_argnums=[4, 5])
def potential(i, r, R, Q, point_func, pauli_exclusion=True):
	"""
	The potential at 'r' relative to particle i (that is, excluding self-interaction) 
	with the shape of the potential generate by a point source determined by point_func. 
	Optionally accounts for Pauli exclusion. 

	i
		Index of the particle we are computing the potential relative to.
	r 
		Position of the particle we are computing the potential relative to. 1D, 2. 
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	pauli_exclusion
		Boolean indicating whether to apply Pauli exclusion based on charge polarity or not.
	"""
	q = Q[i]
	R_minus = jnp.delete(R, i, axis=0)
	Q_minus = jnp.delete(Q, i, axis=0)

	def compute():
		distances = lattice_distances(r, R_minus)
		V_expanded = Q_minus * point_func(distances)
		V = jnp.sum(V_expanded)
		return V

	if pauli_exclusion:
		charge_eq = q == Q_minus
		position_eq = r == R_minus
		V = jax.lax.cond(jnp.any(charge_eq & position_eq), lambda: jnp.inf, lambda: compute)

	return V


def potential_energy(V, q):
	return jax.lax.where(V == jnp.inf, jnp.inf, q * V)


@partial(jax.jit, static_argnums=[4, 5])
def potential_energy_factors(i, R, Q, point_func, pad_value=-1, factor_limit=None):
	"""
	Computes the individual contribution to the potential energy of particle i 
	produced by each other particle. 

	i
		Index of the particle we are computing the potential relative to.
	R
		Array of particle positions. 2D, kx2.
	Q
		Array of particle charges. 1D, k.	
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	pad_value
		Integer scalar used for padding to remove most zero energy factors. Defaults to -1. 
	factor_limit
		Integer scalar giving the maximum number of particles within potential range of i. 
		Defaults to None.
	"""
	r, q = R[i], Q[i]
	R_minus = jnp.delete(R, i, axis=0)
	Q_minus = jnp.delete(Q, i, axis=0)
	
	def energy_fn(s, p):
		distance = lattice_distance(r, s)
		energy = q * p * point_func(distance)
		return energy

	energy_factors = jax.vmap(energy_fn)(R_minus, Q_minus)
	if factor_limit is not None:
		nonzero_indices = jnp.nonzero(energy_factors, size=factor_limit, fill_value=pad_value)
		energy_factors = energy_factors[nonzero_indices]
		nonzero_indices = nonzero_indices.at[nonzero_indices >= i].add(1)	# reset the indices correctly
		indices = nonzero_indices
	else:
		indices = jnp.arange(R_minus.shape[0])
		indices = indices.at[i:].add(1)	# reset the indices correctly

	return energy_factors, indices


def potential_energy_factors_bulk(j, prev_bound_states, curr_bound_states, 
								  all_energy_factors, all_factor_indices, pad_value=-1):
	k = curr_bound_states.shape[0]
	new_particles_mask = jnp.logical_xor(curr_bound_states == j, prev_bound_states == j)
	filtered_energies = jnp.where(new_particles_mask, all_energy_factors, 0)
	filtered_indices = jnp.where(new_particles_mask, all_factor_indices, pad_value)
	energy_factors = jnp.zeros(k)
	energy_factors = energy_factors.at[filtered_indices].add(filtered_energies)
	return energy_factors


def bonded(U, max_energy):
	return U <= max_energy


def bonds(i, energy_factors, factor_indices, max_energy, pad_value):
	"""
	Calculates the bonds of particle i, with bonds defined by a maximum energy of i due to the bond.
	Assumes that particle i is bonded and max_energy < 0. 
	energy_factors:
		Array containing portions of the potential energy of particle i 
		generated by the interaction of other particles. 1D. 
	"""
	sorted_indices = jnp.argsort(energy_factors)
	energy_factors = energy_factors[sorted_indices]
	factor_indices = factor_indices[sorted_indices]

	def find_bond(args):
		remaining_energies = args[0]
		energy_sums = jnp.cumsum(remaining_energies)
		index = jnp.argmax(energy_sums <= max_energy)
		remaining_energies = remaining_energies.at[:index+1].set(0)
		return index, remaining_energies

	def end_fn(args):
		index, remaining_energies = args
		return index == 0 and remaining_energies[0] == 0

	index, _ = jax.lax.while_loop(end_fn, find_bond, (0, energy_factors))
	factor_indices = factor_indices.at[index+1:].set(pad_value)
	return factor_indices


def bound_state(i, all_bonds, pad_value):
	"""
	i
		Index of the particle whose bound state we are computing. 
	all_bonds
		Array of indices, pad_value-padded, which indicates the particles bonded 
		to each particle of the system. 2D, kxm.
 	"""
	state = bfs(all_bonds, i, pad_value)
	return state


def bound_states(all_bonds, pad_value):
	"""
	Calculates all of the bound states, or "molecules", specified by the array all_bounds. 
	Returns a 1D Array of size k giving the label integer of the bound state associated to each particle. 
	"""
	k = all_bonds.shape[0]
	curr_particle = jnp.int32(0)
	visited = jnp.zeros(k, dtype=bool)
	bound_states = jnp.zeros(k, dtype=int)
	bound_state_count = jnp.int32(-1)

	def cond_fn(args):
		visited = args[1]
		return jnp.all(visited)

	def get_molecule(curr_particle, visited, bound_states):
		bound_state_count += 1
		molecule = bound_state(curr_particle, all_bonds, pad_value)
		bound_states = bound_states.at[molecule].set(bound_state_count)
		visited = visited.at[molecule].set(True)
		curr_particle += 1
		return curr_particle, visited, bound_states

	def body_fn(args):
		curr_particle, visited, bound_states = args
		seen = visited[curr_particle]
		next_fn = lambda j, *args: (j+1,) + args
		return jax.lax.cond(seen, next_fn, get_molecule, *args)

	bound_states = jax.lax.while_loop(cond_fn, body_fn, (curr_particle, visited, bound_states))[-1]
	return bound_states


def centers_of_mass(R, bound_states, masses, pad_value):
	"""Returns the center of mass of each bound state in a padded 'k' length 1D Array."""
	k = R.shape[0]
	position_sums = jnp.zeros((k, 2), dtype=int)
	counts = jnp.zeros((k,), dtype=int)
	position_sums = position_sums.at[bound_states].add(masses*R)
	mass_sums = counts.at[bound_states].add(masses)
	# use a mask to handle padding
	centers = jnp.where(mass_sums > 0, position_sums / mass_sums, pad_value)	
	return centers


def moments_of_inertia(R, coms, bound_states, masses, pad_value):
	"""Returns the moment of inertia of each bound state in a padded 'k' length 1D Array."""
	k = R.shape[0]
	MOIs = jnp.zeros((k,))
	arm_lengths = lattice_distance(R, coms)
	particle_MOIs = masses * arm_lengths
	MOIs = MOIs.at[bound_states].add(particle_MOIs)
	return MOIs


def rotate(R, coms, thetas):
	"""
	Rotates each particle about a given center of mass by a multiple 'theta' of 90 degrees,
	upper bounded by 270 degrees. 

	R
		Array of particle positions. 2D, kx2.
	coms
		Array of centers of mass. 2D, kx2.
	thetas
		Array of angles. 1D, k. 
	"""
	# if at all slow could convert to direct array creation
	rotate_matrix90 = jnp.array([[0, -1], [1, 0]])
	rotate_matrix180 = jnp.array([[-1, 0], [0, -1]])
	rotate_matrix270 = jnp.array([[0, 1], [-1, 0]])

	@partial(jax.jit, static_argnums=[1])
	def origin_rotate(r, theta=90):
		if theta == 0:
			r_new = r
		elif theta == 90:
			r_new = rotate_matrix90 @ r 
		elif theta == 180:
			r_new = rotate_matrix180 @ r
		elif theta == 270:
			r_new = rotate_matrix270 @ r
		return r_new

	rotation_branches = tuple(partial(origin_rotate, theta=i) for i in (0, 90, 180, 270))
	
	def rotation_fn(r, com, theta):
		theta_idx = theta // 90
		r_centered = r - com
		r_centered_rotated = jax.lax.switch(theta_idx, rotation_branches, r_centered)
		r_rotated = r_centered_rotated + com
		return r_rotated

	R_rotated = jax.vmap(rotation_fn)(R, coms, thetas)
	return R_rotated


def difference_arrays(V):
	x_diffs = jnp.diff(V, axis=0)
	y_diffs = jnp.diff(V, axis=-1)
	zero_row = jnp.zeros((1, V.shape[-1]))
	zero_col = jnp.zeros((V.shape[0], 1))
	x_delta = jnp.concatenate(zero_row, x_diffs, zero_row, axis=0)
	y_delta = jnp.concatenate(zero_col, y_diffs, zero_col, axis=-1)
	return x_delta, y_delta


def interaction_field(Vx_delta, Vy_delta):
	# multiply by charge to get force
	x_component = (Vx_delta[1:, :] + Vx_delta[:-1, :]) / 2
	y_component = (Vy_delta[:, 1:] + Vy_delta[:, :-1]) / 2
	return jnp.stack(x_component, y_component)


@jax.jit
def planck_logdensity_fn(F, beta, alpha, delta):
	return jnp.log(alpha) + (jnp.log(F) * 3) - jnp.log(jnp.exp(beta * delta * F) - 1)


@jax.jit
def gamma_logdensity_fn(x, a, theta):
	return jnp.log(x)*(a - 1) - (x / theta)


@partial(jax.jit, static_argnums=[1, 2, 3, 4, 5, 6])
def planck(key, beta, alpha, delta, theta, M, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample_gamma(data):
		key, _ = data
		key, subkey = jax.random.split(key)
		F = jnp.exp(jax.random.loggamma(subkey, 4)) * theta
		return key, F

	@jax.jit
	def sample(key):

		@jax.jit
		def reject_fn(data):
			key, F = data
			key, subkey = jax.random.split(key)
			planck_logdensity = planck_logdensity_fn(F, beta, alpha, delta)
			gamma_logdensity = gamma_logdensity_fn(F, 4, theta)
			accept_ratio = jnp.exp(planck_logdensity - jnp.log(M) - gamma_logdensity)
			u = jax.random.uniform(subkey)
			return u >= accept_ratio

		key, F = sample_gamma((key, 0))
		_, F = jax.lax.while_loop(reject_fn, sample_gamma, (key, F))
		return F

	samples = jax.vmap(sample)(keys)
	return samples


@partial(jax.jit, static_argnums=[1, 2, 3])
def wien_approximation(key, beta, alpha, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample(key):
		return jnp.exp(jax.random.loggamma(key, 4) - jnp.log(alpha) - jnp.log(beta))

	samples = jax.vmap(sample)(keys)
	return samples


def occupation_mask(n, R):
	"""
	Returns a particle occupation indicator array for an nxn space, 
	based on the particle positions contained in R.

	n
		Number of lattice sites in each dimension of the space.
	R
		Array of particle positions. 2D, kx2. 
	"""
	mask = jnp.zeros((n, n), dtype=int).at[R[:, 0], R[:, 1]].set(1)
	return mask


def masked(x, y, occupation_mask):
	"""
	Implements drive masking that treats particles as perfect barriers. 
	Returns 0 if there is a particle in {x} x (y,n], 1 otherwise. 
	"""
	column = occupation_mask[x]
	i = jnp.argmax(column)
	v = jnp.max(column)
	return v == 0 or y <= i


@partial(jax.jit, static_argnums=[1, 2, 3])
def brownian_noise(key, beta, gamma, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample(key):
		return jnp.sqrt(2*gamma / beta) * jax.jax.random.normal(key)

	samples = jax.vmap(sample)(keys)
	return samples


def calculate_work(path, field, coupling_constant):
	"""
	Calculate the work done by a field on a particle moving along a path, 
	with the strength of the interaction determined by the appropriate 
	coupling constant of the particle (e.g. charge or mass).

	path
		Array of adjacent positions, 0-padded. 2D, nx2. Assuming the path is length at most n-1. 
	field
		Array of field values at each position in space. 2D, nxn.
	coupling_constant
		Scalar. 
	"""
	steps = jnp.diff(path, axis=0)
	end = jnp.argmin(path, axis=0)[0] - 1

	def add_work_step(i, work):
		r = path[i]
		delta = steps[i]
		work_step = jnp.dot(field[r], delta)
		return work + work_step

	work = jax.lax.fori_loop(0, end, add_work_step, 0)
	return coupling_constant * work 	# multiply coupling at the end for efficiency


def calculate_work_v2(path, field, coupling_constant):
	"""
	Calculate the work done by a field on a particle moving along a path, 
	with the strength of the interaction determined by the appropriate 
	coupling constant of the particle (e.g. charge or mass).

	path
		Array of adjacent positions, 0-padded. 2D, nx2. Assuming the path is length at most n-1. 
	field
		Array of field values at each position in space. 2D, nxn.
	coupling_constant
		Scalar. 
	"""
	steps = jnp.diff(path, axis=0)
	end = jnp.argmin(path, axis=0)[0] - 1

	def work_step(r, delta):
		return jnp.dot(field[r], delta)

	work_steps = jax.vmap(work_step)(path, steps)
	work_steps[end] = 0		# to remove contribution from last fake delta
	work = jnp.sum(work_steps)

	return coupling_constant * work 	# multiply coupling at the end for efficiency


@partial(jax.jit, static_argnums=[3])
def calculate_field(path, field, d, torque=False, com=None):
	"""
	Calculate the net field experienced by a particle moving along a path 
	with a normalization constant 'd'. 

	path
		Array of adjacent positions, 0-padded. 2D, nx2. Assuming the path is length at most n-1. 
	field
		Array of field values at each position in space. 2D, nxn.
	d
		Scalar. 
	"""
	end = jnp.argmin(path, axis=0)[0] - 1

	def add_weighted_field(i, field):
		r = path[i]
		weighted_field = field[r] / d
		if torque:
			weighted_field = calculate_torque(r, com, force)
		return field + weighted_field

	field = jax.lax.fori_loop(0, end, add_weighted_field, 0)
	return field 


calculate_torque_field = partial(calculate_field, torque=True)


@partial(jax.jit, static_argnums=[5])
def net_force(path, field_external, coupling_constant, d, force_random, torque=False, com=None):
	end = jnp.argmin(path, axis=0)[0] - 1
	end_position = path[end]
	weighted_last_field = field_external[end_position] * (d - end) / d
	weighted_last_force = coupling_constant * weighted_last_field

	if torque:
		weighted_path_field = calculate_torque_field(path, field_external, d, com=com)
	else:
		weighted_path_field = calculate_field(path, field_external, d)

	weighted_path_force = coupling_constant * weighted_path_field
	force = force_random + weighted_last_force

	if torque:
		force = calculate_torque(end_position, com, force)

	return force + weighted_path_force


net_torque = partial(net_force, torque=True)


def calculate_torque(r, r_axis, force):
	position_vec = r - r_axis
	return jnp.cross(position_vec, force)


def transferred_force(r_source, force_source, r_dest, m, m_block, I_block, torque_block):
	angular_component = m * jnp.cross(torque_block, r_dest - r_source) / I_block
	linear_component = m * force_source / m_block
	return linear_component + angular_component


def calculate_excitations(i, R, L, work, delta, pad_value):
	"""
	Calculates the energy received by each particle in an energy emission event.
	Uses a simple dispersal method where each particle within 'delta' distance 
	receives an energy amount proportional to its distance from the source particle i. 
	No screening from other particles.

	i
		Index of the particle generating the spontaneous emission. 
	R
		Array of particle positions. 2D, kx2.
	L
		Array of lattice sites, with each element indicating whether the site is empty or filled.
		If an element is pad_value, it is empty, otherwise it is filled with the element 
		indicating the index of the particle. Assumes at most two particles may occupy each site. 
		3D, nxnx2. 
	work
		Scalar, the amount of work released during the emission. 
	delta
		Range of radiation emission. 
	pad_value
		Scalar used for padding, in particular indicating unoccupied slots in L. 

	Returns:
		An Array representing a delta radius square around i with each element 
		giving the amount of energy received at that position. 
	"""
	r = R[i]
	r_square, r_square_positions = centered_square(L, r, delta)
	distances = lattice_distances(r, r_square_positions)

	excited_mask = (distances <= delta) and (distances != 0)	# exclude r itself from excitation
	excited_particle_mask = (r_square != pad_value) & excited_mask

	inv_distances = 1 / distances
	inv_distances = inv_distances.at[inv_distances == jnp.inf].set(0)
	# factor of 2 to account for two particle sites at each posiiton
	normalizer = 1 / jnp.sum(2 * inv_distances * excited_mask)	

	excitations = normalizer * work * inv_distances * excited_particle_mask
	return excitations


def extra_work_factors(work, work_vec, update_vec, mass):
	"""
	Calculates the absorbed work, excess work, and velocity bound update 
	produced by an amount 'work' of energy received by a particle in the direction 'work_vec'
	relative to 'update_vec'.  
	"""
	unit_work_vec = work_vec / jnp.linalg.vector_norm(work_vec)
	unit_update_vec = update_vec / jnp.linalg.vector_norm(update_vec)
	absorbed_work = work * jnp.dot(unit_work_vec, unit_update_vec)
	excess_work = work - absorbed_work
	velocity_bound = jnp.sqrt(2 * work / mass)
	return absorbed_work, excess_work, velocity_bound