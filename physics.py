"""
Note: we use matrix indexing, so row indexing is the first or x dimension and column indexing
is the second or y dimension. 
"""

from functools import partial

import numpy as np

import jax
import jax.numpy as jnp

from utils import *
from geometry import *


def test_potential_factors(r, LQ, LQ_pad_value):
    """
    Computes the individual contribution to the potential at 'r' produced by each particle.
    Does not account for Pauli exclusion. 

    r
        Position we are computing the potential at. 1D, 2.
    LQ
        Array of lattice points filled with either a particle charge or LQ_pad_value. 2D, nxn.
    LQ_pad_value
        Scalar. 
    """
    n = L.shape[0]
    nbhd_idxs = generate_neighborhood(r, n)
    nbhd_charges = LQ[nbhd_idxs[:, 0], nbhd_idxs[:, 1]]
    V_nbhd = jnp.where(nbhd_charges == LQ_pad_value, 0, nbhd_charges)
    return V_nbhd


def test_potential(r, LQ, LQ_pad_value):
    """
    The potential at 'r' generated by particles in the charge occupation lattice LQ 
    and experienced by a test particle placed at 'r'. The test particle should not be 
    included in the lattice. Pauli exclusion is applied by returning a potential of infinity 
    if 'r' is occupied.

    r
        Position we are computing the potential at. 1D, 2.
    LQ
        Array of lattice points filled with either a particle charge or LQ_pad_value. 2D, nxn.
    LQ_pad_value
        Scalar. 
    """
    V_nbhd = test_potential_factors(r, LQ, LQ_pad_value)
    V = jnp.where(nbhd_charges[0] == LQ_pad_value, jnp.sum(V_nbhd), jnp.inf)
    return V


def potential_energy(V, q):
    return jnp.where(V == jnp.inf, jnp.inf, q * V)


def make_potential_energy_func(LQ, LQ_pad_value):

    def func(r, q):
        V = test_potential(r, LQ, LQ_pad_value)
        U = potential_energy(V, q)
        return U

    return func


def bound(u):
    return u < 0


@partial(jax.jit, static_argnums=[1, 2, 3, 4, 5, 6])
def planck(key, beta, alpha, delta, theta, M, num_samples):
    keys = jax.random.split(key, num=num_samples)

    @jax.jit
    def sample_gamma_fn(data):
        key, _ = data
        key, subkey = jax.random.split(key)
        F = jnp.exp(jax.random.loggamma(subkey, 4)) * theta
        return key, F

    @jax.jit
    def sample_fn(key):

        @jax.jit
        def reject_fn(data):
            key, F = data
            key, subkey = jax.random.split(key)
            planck_logdensity = planck_logdensity_fn(F, beta, alpha, delta)
            gamma_logdensity = gamma_logdensity_fn(F, 4, theta)
            accept_ratio = jnp.exp(planck_logdensity - jnp.log(M) - gamma_logdensity)
            u = jax.random.uniform(subkey)
            return u >= accept_ratio

        key, F = sample_gamma_fn((key, 0))
        _, F = jax.lax.while_loop(reject_fn, sample_gamma_fn, (key, F))
        return F

    samples = jax.vmap(sample_fn)(keys)
    return samples


@partial(jax.jit, static_argnums=[1, 2, 3])
def wien_approximation(key, beta, alpha, num_samples):
    keys = jax.random.split(key, num=num_samples)

    @jax.jit
    def sample_fn(key):
        return jnp.exp(jax.random.loggamma(key, 4) - jnp.log(alpha) - jnp.log(beta))

    samples = jax.vmap(sample_fn)(keys)
    return samples


def masked(x, y, occupation_mask):
    """
    Implements drive masking that treats particles as perfect barriers. 
    Returns 0 if there is a particle in {x} x [0,y), 1 otherwise. 
    Drive comes in from the side, making x-dimension correspond to rows, per C indexing.   
    """
    row = occupation_mask[x]
    i = jnp.argmax(row)
    v = jnp.max(row)
    return (v == 0) | (y <= i)


@partial(jax.jit, static_argnums=[0, 3])
def generate_drive_field(n, R, top_field, mask_func):
    occupied = occupation_mask(n, R)
    field = jnp.broadcast_to(top_field, (n, n))
    mask_fn = lambda x, y: mask_func(x, y, occupied)
    particle_mask = jnp.fromfunction(mask_fn, (n, n), dtype=int)
    return jnp.stack((jnp.zeros((n, n)), particle_mask * field), axis=-1)


@partial(jax.jit, static_argnums=[3, 4])
def calculate_momentum_vectors(p, field, q, mu, gamma):
    p_v = (1 - gamma) * p
    impulse = mu * q * field
    p_nv = p + impulse
    p_ne = p_v + impulse
    return p_v, p_nv, p_ne


def calculate_kinetic_factors(p, p_nv, p_ne, m):
    p_squared = jnp.dot(p, p)
    p_nv_squared = jnp.dot(p_nv, p_nv)
    p_ne_squared = jnp.dot(p_ne, p_ne)
    double_m = 2 * m
    Q_delta_momentum = (p_nv_squared - p_ne_squared) / double_m
    E_emit = (p_nv_squared - p_squared) / double_m
    return Q_delta_momentum, E_emit, (p_ne_squared / double_m)


def determine_emissions(U, is_bound, E_emit, K_ne, epsilon):
    energy_to_emit = E_emit > 0
    high_energy = K_ne >= (-epsilon * U)
    return jnp.logical_and(jnp.logical_and(energy_to_emit, is_bound), high_energy)


def calculate_heat_released(p_ne, e, Q_delta_mom, U, U_e, mu):
    Q_delta_pot = U_e - U
    Q_delta = Q_delta_mom + (mu * jnp.dot(p_ne, e)) - Q_delta_pot
    return Q_delta