"""
Note: we use matrix indexing, so row indexing is the first or x dimension and column indexing
is the second or y dimension. 
"""

from functools import partial

import jax
import jax.numpy as jnp

from utils import *
from geometry import *


def occupied_neighbors(nbhd_I, R, n, pad_value):
    return neighborhood_mask(nbhd_I, R, n, pad_value).any(1)


def test_potential_energies(R_I, Q_I, R_test, Q, n, pad_value):
    nbhd = jax.vmap(generate_open_neighborhood, in_axes=(0, None, None))(R_I, n, pad_value)
    nbhd_mask = neighborhood_mask(nbhd, R_test, n, pad_value).any(-1)
    V = jnp.sum(nbhd_mask * Q[None, :], axis=-1)
    U = V * Q_I
    return U


@partial(jax.jit, static_argnums=[4, 5])
def neighborhood_potential_energies(I, nbhd_I, Q, R, n, pad_value):
    Q_I = Q[I]
    R_test = R.at[I].set(pad_value)

    # for pauli exclusion
    nbhd_occupation = occupied_neighbors(nbhd_I, R_test, n, pad_value)

    U_nbhd = jax.vmap(test_potential_energies, in_axes=(1, None, None, None, None, None))(
        nbhd_I, Q_I, R_test, Q, n, pad_value).T
    U_nbhd += jnp.nan_to_num(nbhd_occupation * jnp.inf, posinf=jnp.inf)
    return U_nbhd


@partial(jax.jit, static_argnums=[5, 6, 7])
def neighborhood_potential_energies_dynamic(I, nbhd_I, Q, R, indices, n, buffer_size, pad_value):
    R_test = R.at[I].set(pad_value)
    remaining = I != pad_value
    slice_ = jnp.extract(remaining, indices, size=buffer_size, fill_value=pad_value)
    U_nbhd = jnp.zeros(nbhd_I.shape[:2])

    def cond_fn(args):
        remaining = args[2]
        return jnp.any(remaining)

    def potential_fn(args):
        U_nbhd, slice_, remaining = args
        I_slice = I[slice_]
        nbhd_I_slice = nbhd_I[slice_]
        Q_Is = Q[I_slice]

        # for pauli exclusion
        nbhd_occupation = occupied_neighbors(nbhd_I_slice, R_test, n, pad_value)

        U_nbhd_slice = jax.vmap(test_potential_energies, in_axes=(1, None, None, None, None, None))(
            nbhd_I_slice, Q_Is, R_test, Q, n, pad_value).T

        # update the carry
        U_nbhd = U_nbhd.at[slice_].add(
            U_nbhd_slice + jnp.nan_to_num(nbhd_occupation * jnp.inf, posinf=jnp.inf))
        remaining = remaining.at[slice_].set(False, mode="drop")
        slice_ = jnp.extract(remaining, indices, size=buffer_size, fill_value=pad_value)
        return U_nbhd, slice_, remaining

    U_nbhd = jax.lax.while_loop(cond_fn, potential_fn, (U_nbhd, slice_, remaining))[0]
    return U_nbhd


@partial(jax.jit, static_argnums=[2])
def potential_factors(r, LQ, pad_value):
    """
    Computes the individual contribution to the potential at 'r' produced by each particle.
    Does not account for Pauli exclusion. 

    r
        Position we are computing the potential at. 1D, 2.
    LQ
        Array of lattice points filled with either a particle charge or pad_value. 2D, nxn.
    pad_value
        Scalar.
    """
    n = LQ.shape[0]
    nbhd_idxs = generate_open_neighborhood(r, n, pad_value)
    nbhd_charges = LQ.at[nbhd_idxs[:, 0], nbhd_idxs[:, 1]].get(mode="fill", fill_value=0)
    V_nbhd = jnp.where(nbhd_charges == pad_value, 0, nbhd_charges)
    return V_nbhd


@partial(jax.jit, static_argnums=[2])
def potential(r, LQ, pad_value):
    """
    The potential at 'r' generated by particles in the charge occupation lattice LQ 
    and experienced by a particle at 'r'. Gives the same result regardless of whether
    'r' is occupied in LQ or not. 

    r
        Position we are computing the potential at. 1D, 2.
    LQ
        Array of lattice points filled with either a particle charge or pad_value. 2D, nxn.
    pad_value
        Scalar.
    """
    V_nbhd = potential_factors(r, LQ, pad_value)
    V = jnp.sum(V_nbhd)
    return V


def potential_energy(V, q):
    return q * V


def make_potential_energy_func(LQ, pad_value):

    def func(r, q):
        V = potential(r, LQ, pad_value)
        U = potential_energy(V, q)
        return U

    return func


def compute_potential_energies(R, Q, LQ, pad_value):
    energy_fn = make_potential_energy_func(LQ, pad_value)
    return jax.vmap(energy_fn)(R, Q)


def compute_energies(U, K):
    return U + K


def bound(E):
    return E < 0


def compute_bond_data(i, K, R, L, Q, pad_value):
    n, k = L.shape[0], R.shape[0]
    r, q = R[i], Q[i]

    r_nbhd = generate_open_neighborhood(r, n, pad_value)
    nbhd = L.at[r_nbhd[:, 0], r_nbhd[:, 1]].get(mode="fill", fill_value=pad_value)
    nbhd_charges = Q.at[nbhd].get(mode="fill", fill_value=0)

    energy_factors = q * nbhd_charges
    is_bound = (jnp.sum(energy_factors) + K) < 0
    return nbhd, energy_factors, is_bound


@partial(jax.jit, static_argnums=[3])
def determine_bonds(energy_factors, nbhd, is_bound, pad_value):
    nbhd_bound = is_bound[nbhd]
    bonded_nbhd = (energy_factors < 0) & nbhd_bound
    return jnp.extract(bonded_nbhd, nbhd, size=4, fill_value=pad_value)


@partial(jax.jit, static_argnums=[2])
def compute_bound_state(i, bonds, pad_value):
    """
    i 
        Index of the particle whose bound state we are computing.
    bonds
        Array of indices with index-safe padding which indicates the particles bonded to each particle. 
        Should contain all the particles in a subset of the bound states. 2D, mx4.
    """
    state = bfs(bonds, i, pad_value)
    return state


@partial(jax.jit, static_argnums=[4, 5])
def compute_bound_states(I, bonds, bound_states, visited, l, pad_value):
    """
    Calculates the bound states, or "molecules", of particles in 'I' specified by the array 'bonds' 
    starting from the partially discovered 'bound_states' inhibitated by particles that are 'visited'.

    Returns a 1D Array of size k giving the label integer of the bound state 
    associated to each particle.
    """
    I_slice = jnp.extract(~visited, I, size=l, fill_value=pad_value)

    def cond_fn(args):
        visited = args[2]
        return ~jnp.all(visited)

    def find_fn(args):
        I, I_slice, visited, bound_states = args

        new_states = jax.vmap(compute_bound_state, in_axes=(0, None, None))(I_slice, bonds, pad_value)
        labels = jnp.argmax(new_states, axis=-1, keepdims=True)
        repeats = jnp.sum(new_states, axis=0)

        new_states = jnp.sum(new_states * labels, axis=0) // repeats    # 0 becomes -1 from floor divide
        visited_new = repeats.astype(bool)
        bound_states = jnp.where(visited_new, new_states, bound_states)
        visited = jnp.logical_or(visited_new, visited)

        I_slice = jnp.extract(~visited, I, size=l, fill_value=pad_value)

        return I, I_slice, visited, bound_states

    bound_states = jax.lax.while_loop(cond_fn, find_fn, (I, I_slice, visited, bound_states))[3]
    return bound_states

### unused ideas
### - could consider vmapping by sorting I to separate particles likely 
### in different bound states to reduce redundant computation
### - could consider early termination of the bfs
### - more difficult: stitching bound states together, allowing for reduced computation
### - track change in potential energy / new neighbors


def centers_of_mass(R, M, bound_states):
    """
    Returns the center of mass and mass of each bound state 
    in a 0-padded 'k' length 2D Array and 1D Array, respectively.
    """
    mass_sums = compute_group_sums(M, bound_states)
    position_sums = compute_group_sums(M[..., None] * R, bound_states)
    # use a mask to handle padding
    mass_sums_expanded = mass_sums[..., None]
    centers = jnp.where(mass_sums_expanded > 0, position_sums / mass_sums_expanded, 0)
    return centers, mass_sums


def move(R, shifts, n):
    """Move each particle using reference points. Should be a valid lattice translation."""
    return cylindrical_coordinates(R + shifts, n)


def planck_logdensity_fn(F, alpha, delta):
    return jnp.log(alpha) + (jnp.log(F) * 3) - jnp.log(jnp.exp(delta * F) - 1)


def gamma_logdensity_fn(x, a, theta):
    return jnp.log(x)*(a - 1) - (x / theta)


@partial(jax.jit, static_argnums=[1, 2, 3, 4, 5])
def planck(key, alpha, delta, theta, M, num_samples):
    keys = jax.random.split(key, num=num_samples)

    @jax.jit
    def sample_gamma_fn(data):
        key, _ = data
        key, subkey = jax.random.split(key)
        F = jnp.exp(jax.random.loggamma(subkey, 4)) * theta
        return key, F

    @jax.jit
    def sample_fn(key):

        @jax.jit
        def reject_fn(data):
            key, F = data
            key, subkey = jax.random.split(key)
            planck_logdensity = planck_logdensity_fn(F, alpha, delta)
            gamma_logdensity = gamma_logdensity_fn(F, 4, theta)
            accept_ratio = jnp.exp(planck_logdensity - jnp.log(M) - gamma_logdensity)
            u = jax.random.uniform(subkey)
            return u >= accept_ratio

        key, F = sample_gamma_fn((key, 0))
        _, F = jax.lax.while_loop(reject_fn, sample_gamma_fn, (key, F))
        return F

    samples = jax.vmap(sample_fn)(keys)
    return samples


@partial(jax.jit, static_argnums=[1, 2])
def wien_approximation(key, alpha, num_samples):
    keys = jax.random.split(key, num=num_samples)

    @jax.jit
    def sample_fn(key):
        return jnp.exp(jax.random.loggamma(key, 4) - jnp.log(alpha))

    samples = jax.vmap(sample_fn)(keys)
    return samples


def masked(x, y, occupation_mask):
    """
    Implements drive masking that treats particles as perfect barriers. 
    Returns 0 if there is a particle in {x} x [0,y), 1 otherwise. 
    Drive comes in from the side, making x-dimension correspond to rows, per C indexing.   
    """
    row = occupation_mask[x]
    i = jnp.argmax(row)
    v = jnp.max(row)
    return (v == 0) | (y <= i)


@partial(jax.jit, static_argnums=[4, 5, 6])
def generate_drive_field(top_field, R, P, M, mask_func, n, kappa):
    k = R.shape[0]

    # apply particle masking to base field values
    occupied = generate_unlabeled_lattice(R, n)
    base_field = jnp.broadcast_to(top_field, (n, n))
    mask_fn = lambda x, y: mask_func(x, y, occupied)
    particle_mask = jnp.fromfunction(mask_fn, (n, n), dtype=int)
    base_field = particle_mask * base_field

    # construct Lorentz field
    base_field = base_field[R[:, 0], R[:, 1]]
    k_zeros = jnp.zeros((k,))
    E = jnp.stack((base_field, k_zeros), axis=-1)
    V = P / M[..., None]
    B = jnp.stack((k_zeros, k_zeros, base_field), axis=-1)
    F = E + jnp.cross(jnp.concatenate((V, k_zeros[..., None]), axis=-1), B / kappa)[:, :2]
    return F


@partial(jax.jit, static_argnums=[1, 2, 3])
def brownian_noise(key, beta, gamma, num_samples):
    keys = jax.random.split(key, num=num_samples)

    @jax.jit
    def sample_fn(key):
        return jnp.sqrt(2*gamma / beta) * jax.random.normal(key)

    samples = jax.vmap(sample_fn)(keys)
    return samples


def calculate_impulse(force, mu):
    return mu * force


def calculate_momentum_vectors(p, force, mu, gamma):
    p_v = (1 - gamma) * p
    impulse = calculate_impulse(force, mu)
    p_ne = p_v + impulse
    return p_ne, p_v, impulse


def lattice_norm_squared(p):
    return jnp.linalg.vector_norm(p, axis=-1, ord=1) ** 2


def kinetic_energy(p, m_double):
    return lattice_norm_squared(p) / m_double


def compute_kinetic_energies(P, M_double):
    return jax.vmap(kinetic_energy)(P, M_double)


def kinetic_energy_difference(K, p, m_double):
    K2 = (lattice_norm_squared(p) / m_double)
    return K2 - K, K2


def compute_kinetic_terms(I, P, net_force, U_grad, M, mu, gamma):
    P, M = P[I], M[I]
    net_force = net_force[I, None, :] - U_grad
    momentum_fn = jax.vmap(jax.vmap(
        calculate_momentum_vectors, in_axes=(None, 0, None, None)), in_axes=(0, 0, None, None))
    P_ne, P_v, impulse = momentum_fn(P, net_force, mu, gamma)
    M_double = 2 * M
    K = compute_kinetic_energies(P, M_double)
    K_ne = jax.vmap(jax.vmap(kinetic_energy, in_axes=(0, None)))(P_ne, M_double)
    
    return M, P, K, P_v, P_ne, K_ne, M_double, impulse


def compute_potential_terms(U_nbhd):
    U = U_nbhd[:, 0]
    U_nbhd_diff = U_nbhd - U[:, None]
    U_grad = U_nbhd_diff[..., None] * get_shifts()[None, ...]
    U_grad = jnp.nan_to_num(U_grad, posinf=jnp.inf, neginf=-jnp.inf)
    return U, U_nbhd_diff, U_grad


def calculate_heat_released(K, p_ne, K_ne, e, U_diff, m, mu):
    e = e.astype(p_ne.dtype)
    Q_delta = (jnp.dot(p_ne, e) / (m * mu)) + K - K_ne - U_diff
    return Q_delta


def calculate_probabilities(K, P_ne, K_ne, U_diff, boundary_mask, M, mu, beta):
    shifts = get_shifts()
    heat_fn = jax.vmap(jax.vmap(calculate_heat_released, 
        in_axes=(None, 0, 0, 0, 0, None, None)), in_axes=(0, 0, 0, None, 0, 0, None))
    Q_deltas = heat_fn(K, P_ne, K_ne, shifts, U_diff, M, mu)
    logdensities = beta * Q_deltas
    densities = boundary_mask * jnp.exp(logdensities)
    Z = jnp.sum(densities, axis=-1)
    probabilities = densities / Z[..., None]
    return probabilities, logdensities


def entropy(probabilities):
    logp = jnp.log(probabilities)
    S = -jnp.sum(jnp.nan_to_num(probabilities * logp, nan=0.0))
    return S


def emission_energy(K, p, impulse, m_double):
    p_nv = p + impulse
    return kinetic_energy_difference(K, p_nv, m_double)[0]


def determine_emissions(U, is_bound, E_emit, K_ne, epsilon):
    energy_to_emit = E_emit > 0
    high_energy = K_ne >= (-epsilon * U)
    return jnp.logical_and(jnp.logical_and(energy_to_emit, is_bound), high_energy)


def calculate_emissions(r, L, M, Q, P, E_emit, delta, mu, pad_value):
    """
    Calculates the field update vector for each particle in an energy emission event at 'r'.
    Uses a simple dispersal method where each particle within 'delta' distance receives
    an energy amount proportional to its distance from the source particle at 'r'.
    No screening from other particles.

    r
        Position of the source particle, matching L. 2D, 2.
    L
        Array of lattice sites, with each filled site indicated by the index of the particle.
        Otherwise filled with 'pad_value'. 2D, nxn.
    M
        Array of particle masses. 1D, k.
    Q 
        Array of particle charges. 1D, k.
    P
        Array of particle momenta. 2D, kx2. 
    E_emit
        Energy emitted by the particle at 'r'. Assumed to be positive.
    delta
        Range of energy emission.
    mu
        Scalar.
    """
    n = L.shape[0]
    Lr_square, Lr_square_positions = centered_square(L, r, delta)
    Mr_square, Qr_square, Pr_square = M[Lr_square], Q[Lr_square], P[Lr_square]
    distances = lattice_distances_2D(r, Lr_square_positions, n)

    excited_mask = (distances <= delta) & (distances != 0)  # exclude r itself from excitation
    excited_particle_mask = (Lr_square != pad_value) & excited_mask

    inv_distances = 1 / distances
    inv_distances = jnp.where(inv_distances == jnp.inf, 0.0, inv_distances)
    normalizer = 1 / jnp.sum(inv_distances * excited_mask)

    directions = Lr_square_positions - r[None, ...]
    Pr_norm_square = jnp.linalg.vector_norm(Pr_square, axis=-1, ord=1)

    field = 2 * Mr_square * normalizer * E_emit
    field = (Pr_norm_square ** 2) + (field * inv_distances)
    field = jnp.sqrt(field) - Pr_norm_square
    field = directions * inv_distances[..., None] * field[..., None]
    field = field / (mu * Qr_square[..., None])
    field = excited_particle_mask[..., None] * field

    return field, Lr_square_positions


def merge_excitations(field_arrays, position_arrays, n):
    field = jnp.zeros((n, n, 2), dtype=float)
    positions = position_arrays.reshape(-1, 2)
    excitations = field_arrays.reshape(-1, 2)
    field = field.at[positions[:, 0], positions[:, 1], :].add(excitations)
    return field