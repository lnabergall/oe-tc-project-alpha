from functools import partial

import numpy as np

import jax
import jax.numpy as jnp
import jax.scipy as jsp


def potential_everywhere(R, Q, positions, point_func):
	"""
	R
		Array of particle positions. 2D, Kx2.
	Q
		Array of particle charges. 1D, K.
	positions
		Array of all positions in the space. 3D, NxNx2. 
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	"""
	differences = jnp.expand_dims(positions, axis=-2) - R
	distances = jnp.linalg.norm(differences, axis=-1)
	V_expanded = Q * point_func(distances)
	V = jnp.sum(V_expanded, axis=-1)
	return V


def potential_energy_everywhere(R, Q, V):
	"""
	R
		Array of particle positions. 2D, Kx2.
	Q
		Array of particle charges. 1D, K.
	V
		Array of potentials at all positions in space. 2D, NxN.
	"""
	U = Q * V[R[:, 0], R[:, 1]]
	return U


def potential(i, r, R, Q, point_func, pauli_exclusion=True):
	"""
	The potential at 'r' relative to particle i (that is, excluding self-interaction) 
	with the shape of the potential generate by a point source determined by point_func. 
	Optionally accounts for Pauli exclusion. 
	i
		Index of the particle we are computing the potential relative to.
	r 
		Position of the particle we are computing the potential relative to. 1D, 2. 
	R
		Array of particle positions. 2D, Kx2.
	Q
		Array of particle charges. 1D, K.
	point_func
		Function specifying the potential generated by a particle at a given distance. 
	pauli_exclusion
		Boolean indicating whether to apply Pauli exclusion based on charge polarity or not.
	"""
	q = Q[i]
	R_minus = jnp.delete(R, i, axis=0)
	Q_minus = jnp.delete(Q, i, axis=0)

	def compute():
		differences = r - R_minus
		distances = jnp.linalg.norm(differences, axis=-1)
		V_expanded = Q_minus * point_func(distances)
		V = jnp.sum(V_expanded)
		return V

	if pauli_exclusion:	 # jit statically
		charge_eq = q == Q_minus
		position_eq = r == R_minus
		V = jax.lax.cond(jnp.any(charge_eq & position_eq), lambda: jnp.inf, lambda: compute)

	return V


def potential_energy(V, q):
	return jax.lax.where(V == jnp.inf, jnp.inf, q * V)


@jax.jit
def planck_logdensity_fn(F, beta, alpha, delta):
	return jnp.log(alpha) + (jnp.log(F) * 3) - jnp.log(jnp.exp(beta * delta * F) - 1)


@jax.jit
def gamma_logdensity_fn(x, a, theta):
	return jnp.log(x)*(a - 1) - (x / theta)


@partial(jax.jit, static_argnums=[1, 2, 3, 4, 5, 6])
def planck(key, beta, alpha, delta, theta, M, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample_gamma(data):
		key, _ = data
		key, subkey = jax.random.split(key)
		F = jnp.exp(jax.random.loggamma(subkey, 4)) * theta
		return key, F

	@jax.jit
	def sample(key):

		@jax.jit
		def reject_fn(data):
			key, F = data
			key, subkey = jax.random.split(key)
			planck_logdensity = planck_logdensity_fn(F, beta, alpha, delta)
			gamma_logdensity = gamma_logdensity_fn(F, 4, theta)
			accept_ratio = jnp.exp(planck_logdensity - jnp.log(M) - gamma_logdensity)
			u = jax.random.uniform(subkey)
			return u >= accept_ratio

		key, F = sample_gamma((key, 0))
		_, F = jax.lax.while_loop(reject_fn, sample_gamma, (key, F))
		return F

	samples = jax.vmap(sample)(keys)
	return samples


@partial(jax.jit, static_argnums=[1, 2, 3])
def wien_approximation(key, beta, alpha, num_samples):
	keys = jax.random.split(key, num=num_samples)

	@jax.jit
	def sample(key):
		return jnp.exp(jax.random.loggamma(key, 4) - jnp.log(alpha) - jnp.log(beta))

	samples = jax.vmap(sample)(keys)
	return samples


